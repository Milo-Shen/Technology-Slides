// 逆变

// 我们都清楚 TS 属于静态类型检测，所谓类型的赋值是要保证安全性的
// 通俗来说也就是多的可以赋值给少的，上述代码因为 a 的类型定义中完全包括 b 的类型定义，所以 a 类型完全是可以赋值给 b 类型，这被称为类型兼容性
let a1!: { a: string; b: number };
let b1!: { a: string };
b1 = a1;


let fn1!: (a: string, b: number) => void;
let fn2!: (a: string, b: number, c: boolean) => void;
// fn1 = fn2; TS Error: 不能将fn2的类型赋值给fn1
// 针对于 fn1 声明时，函数类型需要接受两个参数，换句话说调用 fn1 时我需要支持两个参数的传入分别是 a:string 和 b:number。
// 同理 fn2 函数定义时，定义了三个参数那么调用 fn2 时自然也需要传入三个参数。
// 那么此时，我们将 fn2 赋值给 fn1 ，我们可以思考下。如果赋值成功了，当我调用 fn1 时，其实相当于调用 fn2 没错吧。
// 但是，由于 fn1 的函数类型定义仅仅支持两个参数 a:string 和 b:number 即可。但是由于我们执行了 fn1 = fn2。
// 调用 fn1 时，实际相当于调用了 fn2 函数。但是类型定义上来说 fn1 满足两个参数传入即可，而 fn2 是实打实的需要传入 3 个参数。
// 那么此时，如果执行了 fn1 = fn2 当调用 fn1 时明显参数个数会不匹配（由于类型定义不一致）会缺少一个第三个参数，显然这是不安全的，自然也不是被 TS 允许的。

// 按照刚才的思路来分析，我们将 fn1 赋值给 fn2。fn2 的类型定义需要支持三个参数的传入，但实际 fn2 内部指针已经被修改称为 fn1 的指针
// fn1 在执行时仅仅需要两个参数 a: string, b: number，显然 fn2 的类型定义中是满足这个条件的（当然它还多传递了第三个参数 c:boolean，在 JS 中对于函数而言调用时的参数个数大于定义时的参数个数是被允许的）。
// 自然，这是安全的也是被 TS 允许赋值
fn2 = fn1; // 正确，被允许

// 就比如上述函数的参数类型赋值就被称为逆变，参数少（父）的可以赋给参数多（子）的那一个。看起来和类型兼容性（多的可以赋给少的）相反，但是通过调用的角度来考虑的话恰恰满足多的可以赋给少的兼容性原则。
// 上述这种函数之间互相赋值，他们的参数类型兼容性是典型的逆变